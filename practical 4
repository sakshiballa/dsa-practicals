Beginning with an empty binary search tree, Construct binary search tree by inserting the
values in the order given. After constructing a binary tree -
i. Insert new node
ii. Find number of nodes in longest path from root
iii. Minimum data value found in the tree
iv. Change a tree so that the roles of the left and right pointers are swapped at every
node
v. Search a value.

#include <iostream>
using namespace std;
struct node
{
    int data;
    struct node  *left;
    struct node  *right;

};
class BST
{
    node *root = NULL;
    node *temp=NULL;
    node *t1=NULL;
    node *s=NULL;
    node *t=NULL;
     int count;
     public:
     BST()
     {
         count=0;
     }
     node *createnode();
     void insertnode();
     void del();
     node *delet(node*,int);
     void find();
     void search();
     void sw();
     void swap(node*);
     void height();
     int he(node*,int);
     void disp(node*);
     void display();
     node *findmin(node*);
};
node *BST::createnode()
{
    node *p = new node;
    p->left=NULL;
    p->right=NULL;
    cout<<"\n Enter Data : ";
    cin>>p->data;
    return p;

}
void BST::insertnode()
{
     temp=createnode();
     if(root==NULL)
     {
         root=temp;
     }
     else
     {    t1=root;
          while(t1!=NULL)
          {      s=t1;
                 if((temp->data)>(t1->data))
                 {
                     t1=t1->right;
                 }
                 else
                 {
                     t1=t1->left;
                 }
          }
              if((temp->data)>(s->data))
              {
                     s->right=temp;
              }
              else
              {
                  s->left=temp;
              }
      }
}
void BST::find()
{
    if(root==NULL)
    {    cout<<"\n Tree not exist";  }
    else
    {
         t1=root;

    while(t1->left!=NULL)
    {
                t1=t1->left;
    }

    cout<<"\n smallest no."<<t1->data;
    t1=root;

    while(t1->right!=NULL)
    {
                t1=t1->right;
    }
    cout<<"\n largest no."<<t1->data;
    }
}
void BST::search()
{
      int m,f=0;
      if(root==NULL)
      {  cout<<"\n tree not exist";
      }
      else
      {
              cout<<"\n enter data to be searched";
              cin>>m;
        if(root->data==m)
        {
            cout<<"\ndata found";
        }
        else
        {    t1=root;
             while(t1->data!=m)
             {
                 if((m)>(t1->data))
                 {     t1=t1->right;  }
                 else
                 {   t1=t1->left;       }
                 if(t1==NULL)
                 {   cout<<"\n data not found";     f=1;
                     break;
                 }
             }
          if(f==0)
          {   cout<<"\n data found";    }

        }
      }
}
void BST::sw()
 {
    if(root==NULL)
    {  cout<<"\n tree not exist";
    }
    else
    {
       swap(root);
    }
}
void BST::swap(node *q)
{
   if(q->left!=NULL)
   swap(q->left);
   if(q->right!=NULL)
   swap(q->right);
   t=q->left;
   q->left=q->right;
   q->right=t;
}
void BST::height()
{
    count=0;
    if(root==NULL)
    {  cout<<"\n tree not exist";
    }
    else
    {
    he(root,0); cout<<"\n height of the tree is"<<count;
    }

}
int BST::he(node *q,int c)
{
      c++;
     // cout<<"\n*"<<q->a<<"*"<<c<<"*\n";
          if(q->left!=NULL)
      {      he(q->left,c);
      }
          if(q->right!=NULL)
          {
                he(q->right,c);
          }
          if(count<c)
          {
                count=c;
          }


          return 0;

}
void BST::del()
{     int x;
   cout<<"\n enter data to be deleted";
   cin>>x;
   delet(root,x);

}
node *BST::delet(node *T,int x)
{
     if(T==NULL)
     {
        cout<<"\n element not found";
        return(T);
     }
     if(x<T->data)
     {
         T->left=delet(T->left,x);
         return (T);
     }
     if(x>T->data)
     {
          T->right=delet(T->right,x);
          return T;
     }
     if(T->left==NULL&&T->right==NULL)
     {
        temp=T;
        free(temp);
        return(NULL);
     }
     if(T->left==NULL)
     {
         temp=T;
         T=T->right;
         delete temp;
         return T;
     }
     if(T->right==NULL)
     {
        temp=T;
        T=T->left;
        delete temp;
        return T;
      }
      temp=findmin(T->right);
      T->data=temp->data;
      T->right=delet(T->right,temp->data);
      return T;
}
node *BST::findmin(node *T)
{
    while(T->left!=NULL)
    {  T=T->left;    }
    return T;
}
void BST::display()
{

    if(root==NULL)
    {  cout<<"\n tree not exist";
    }
    else
    {
       disp(root);
    }

}
void BST::disp(node *q)
{
      cout<<"\n*"<<q->data;
          if(q->left!=NULL)
      {      disp(q->left);
      }
          if(q->right!=NULL)
          {
                disp(q->right);
          }

 }
int main()
{
    BST b;
    int x;
    char ch;
    while(1)
     {
               cout<<"\n **&& Binary SEarch Tree &&** ";
               cout<<"\n 1.insert";
               cout<<"\n 2.find";
               cout<<"\n 3.search";
               cout<<"\n 4.swap";
               cout<<"\n 5.height";
               cout<<"\n 6.delete";
               cout<<"\n 7.display";
               cout<<"\n 8.exit";
               cout<<"\n enter your choice : ";
               cin>>x;
               switch(x)
               {
                     case 1: b.insertnode();
                                break;
                     case 2: b.find();
                                break;
                     case 3: b.search();
                                break;
                     case 4: b.sw();
                                break;
                     case 5: b.height();
                                break;
                     case 6: b.del();
                                break;
                     case 7: b.display();
                                break;
                     case 8:exit(0);
               }

       }

    return 0;

}
